## 面试题目汇总

> 题目一共分成框架, css, js, react, vue，其它 6个板块

### css: 
1. <a href="#css-1">如何实现垂直居中？√ </a>
2. <a href="#css-2">如何解决移动端1px像素的兼容问题？</a>
3. <a href="#css-3">介绍一下盒模型 box-sizing: content-box / border-box √</a>
  
### js:
1. <a href="#js-1">var let 声明的区别</a>
2. <a href="#js-2">阐述事件点透 √</a>
3. <a href="#js-3">控制台中 0.1 + 0.2 = ？√</a>
4. <a href="#js-4">ES6里面有哪些特性和语法？√</a>
5. <a href="#js-5">在多个Promise调用链中如何在某个then中捕捉到错误，但是不停止then语句的执行？</a>
    
### 框架
    1. vue 跟 react 之间的区别有哪些方面？
    2. Vue1.0 跟 Vue2.0的变化有哪些地方？
    
#### vue.js
    1. vue有哪些生命周期函数?
    2. vue 的数据绑定在那个阶段？
    3. vue 的实现原理是？
    
#### react.js
    1. react中有哪些周期函数？

### 前端性能优化
1. <a href="#performance-1">阐述前端优化的方面&性能优化</a>

### 其它
1. <a href="#other-1">如何解决跨域问题？有哪些方案？ √</a> 


## 附上部分问题的解答或者相对应的链接：

<h4 id="css-1">如何实现垂直居中?</h4>

```
1. inline-block vertical-align: middle
2. flex 布局
3. position 定位
4. 单行文字：line-height    
```

<h4 id="css-3">介绍一下盒模型 box-sizing: content-box / border-box </h4>

```
1. margin border padding content
2. 盒模型文档: https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/Boxes
```

<h4 id="js-1">let var 之间的区别</h4>

```
var: 变量提升
let: 不存在变量提升，执行的是块级作用域 {} , 声明后才可以使用，称为“暂时性死区”

具体：http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F
```

<h4 id="js-2">事件点透</h4>

```
1. 产生原因：移动端click事件300ms延迟导致的
2. 产生场景：在同一个z轴上存在两个层A,B, 当用户点击B消失的时候，A上的链接就会被触发点击事件
```

<h4 id="js-3">控制台中 0.1 + 0.2 = ？</h4>

```
不等于0.3。因为小数在计算机底层都是近似表示，不是准确的。更深入的原理，可以看下《深入计算机系统》的信息二进制表示这个部分
```

<h4 id="js-4">ES6里面有哪些特性和语法？</h4>

```
1. let const 
2. 解构
3. Promise
4. async / await
5. arrow function
6. 字符串模板

更具体的可以参考阮一峰: http://es6.ruanyifeng.com/
```

<h4 id="js-5">在多个Promise调用链中如何在某个then中捕捉到错误，但是不停止then语句的执行？</h4>

```
我的答案是: 声明一个erroQueue 在链式调用中，将错误信息推入到队列中。这是一道开放题。
```

<h4 id="other-1">如何解决跨域问题</h4>

```
1. cors 跨域资源共享 
2. jsonp 跨域    
```

<h4 id="performance-1">阐述前端优化的方面&性能优化</h4>

```
主要分成2个大的角度去分析： 
1. 资源加载 
    1. cdn加速 原理是资源缓存在离用户近的资源服务器
2. 运行 
    1. index.html 解析 (原理: 让浏览器先完成DOM,CSSOM 的构建，js的阻塞性和js必须等CSSOM先完成构建)
        1. css 在head部引入
        2. js 放在body的最后部分
    2. 减少dom的操作，避免频繁触发重排和重绘
        1. 归并js操作，n次归并成1次
        2. 可以先设置元素隐藏，完成变更后，然后重新插入，这样只会变更一次渲染树
        3. 利用fragment
        4. 让变更的DOM部分脱离文档流，避免影响到文档的其它部分        
    3. 尽量使用setTimeout将函数推进UI线程执行队列 (原理：当有任务在执行的时候，会出现卡死的状况，也没法插入任务到队列中)     
```     